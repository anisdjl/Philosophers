Stack:

The stack is a lifo data structure which means the last data stored in it is the first one out of it
Stored in computer RAM just like the heap.
Variables created on the stack will go out of scope and are automatically deallocated.
Much faster to allocate in comparison to variables on the heap.
Implemented with an actual stack data structure.
Stores local data, return addresses, used for parameter passing.
Can have a stack overflow when too much of the stack is used (mostly from infinite or too deep recursion, very large allocations).
Data created on the stack can be used without pointers.
You would use the stack if you know exactly how much data you need to allocate before compile time and it is not too big.
Usually has a maximum size already determined when your program starts.

Heap:

Stored in computer RAM just like the stack.
In C++, variables on the heap must be destroyed manually and never fall out of scope. The data is freed with delete, delete[], or free.
Slower to allocate in comparison to variables on the stack.
Used on demand to allocate a block of data for use by the program.
Can have fragmentation when there are a lot of allocations and deallocations.
In C++ or C, data created on the heap will be pointed to by pointers and allocated with new or malloc respectively.
Can have allocation failures if too big of a buffer is requested to be allocated.
You would use the heap if you don't know exactly how much data you will need at run time or if you need to allocate a lot of data.
Responsible for memory leaks.

1. Les Bus : Les autoroutes de l'information üöå
Un bus est un ensemble de liaisons physiques (des fils √©lectriques sur la carte m√®re) qui permettent de transf√©rer des donn√©es entre les composants d'un ordinateur (CPU, m√©moire, p√©riph√©riques).

On distingue g√©n√©ralement trois types de bus :
Le Bus de Donn√©es üì¶ : Il transporte les informations r√©elles (le contenu d'une variable, une instruction de code).
Le Bus d'Adresses üìç : Il indique o√π envoyer la donn√©e (l'adresse m√©moire en RAM). Plus ce bus est large (ex: 64 bits), plus l'ordinateur peut g√©rer une grande quantit√© de m√©moire.
Le Bus de Contr√¥le üö¶ : Il transporte les ordres (ex: "Lire", "√âcrire", "Interrompre").

2. La Hi√©rarchie de la M√©moire üèîÔ∏è
Comme nous l'avons vu, la m√©moire est organis√©e en pyramide. Plus on monte vers le CPU, plus c'est rapide, mais plus c'est petit et cher.
Registres ‚ö° : Directement dans le CPU. Vitesse instantan√©e.
M√©moire Cache (L1, L2, L3) üèéÔ∏è : Int√©gr√©e ou proche du CPU. Stocke ce qui est utilis√© fr√©quemment.
M√©moire Vive (RAM) üßä : Stockage temporaire pour les programmes en cours d'ex√©cution.
Stockage de masse (SSD/HDD) üìö : Permanent, tr√®s lent par rapport au CPU.

Le trajet de la donn√©e üõ§Ô∏è
Le Stockage (SSD/HDD) üíæ : Avant que vous ne lanciez le programme, le code compil√© (binaire) et les donn√©es dorment sur le disque dur.
La RAM (M√©moire vive) üßä : Quand vous lancez l'ex√©cutable, le syst√®me d'exploitation charge les instructions en RAM. Une zone appel√©e Stack (Pile) est r√©serv√©e pour les variables locales comme a et b.
Le Cache üèéÔ∏è : Le processeur anticipe et copie les valeurs de a et b depuis la RAM vers le Cache (L1/L2) pour y acc√©der plus vite.
Les Registres ‚ö° : Pour effectuer l'addition (a + b), le CPU transf√®re les valeurs du Cache vers ses Registres internes. C'est seulement ici que l'unit√© de calcul peut manipuler les nombres.

un Dangling Pointer (un pointeur qui pointe vers du vide ou "n'importe quoi").

Au niveau du mat√©riel, un Segfault est un signal d'arr√™t d'urgence envoy√© par le processeur.

La M√©moire Virtuelle et la MMU üß†
Ton programme ne parle jamais directement aux puces de RAM physiques. Il utilise des adresses virtuelles. Entre le processeur et la RAM, il y a un composant physique essentiel appel√© la MMU (Memory Management Unit).

Voici ce qui se passe lors d'une erreur :
La Table des Pages üìñ : Le syst√®me d'exploitation cr√©e une carte (une table) qui dit : "Le programme A a le droit d'acc√©der aux adresses de 100 √† 200".
La Requ√™te ‚úã : Ton processeur essaie d'ex√©cuter une instruction comme MOV (d√©placer une donn√©e) vers une adresse interdite (par exemple l'adresse 0, ou une adresse appartenant √† un autre programme).
Le Verdict de la MMU ‚ùå : La MMU v√©rifie la table. Si l'adresse n'est pas r√©pertori√©e ou si les droits (lecture/√©criture) ne correspondent pas, elle bloque l'acc√®s instantan√©ment.
L'Exception Mat√©rielle ‚ö° : La MMU envoie une "exception" au processeur. Le processeur arr√™te tout et passe la main au noyau (Kernel) du syst√®me d'exploitation, qui envoie alors le signal SIGSEGV √† ton programme pour le tuer proprement avant qu'il ne corrompe les donn√©es des autres.
Pourquoi c'est une protection vitale ? üõ°Ô∏è
Sans ce m√©canisme mat√©riel, si ton programme faisait une erreur, il pourrait aller √©crire par accident dans la m√©moire du syst√®me d'exploitation ou d'un autre logiciel (comme ton navigateur web), ce qui ferait planter tout l'ordinateur.

Pour bien visualiser cela, on peut regarder deux causes mat√©rielles fr√©quentes :
L'acc√®s hors limites : Ton pointeur pointe vers une zone qui n'a jamais √©t√© "mapp√©e" (allou√©e) par la MMU.
La violation de droits : Tu essaies d'√©crire dans une zone marqu√©e comme "Lecture seule" (comme la zone o√π est stock√© le code m√™me de ton programme).

1. Le Core Dump (La bo√Æte noire) üìÇ
Oui, tu peux l'ouvrir ! Sous Linux, on utilise souvent un outil appel√© gdb (GNU Debugger).
Quand tu lances gdb mon_programme core, le d√©bogueur te place exactement √† l'endroit o√π √ßa a cass√©.
Tu peux taper une commande comme backtrace pour voir la liste des fonctions qui √©taient en cours d'ex√©cution.
C'est magique car cela t'√©vite de chercher des heures avec des printf.

I. La Hi√©rarchie et la Circulation des Donn√©es
Tout commence par la structure de la m√©moire, organis√©e en pyramide pour √©quilibrer vitesse et capacit√©. Au sommet, on trouve les Registres, situ√©s dans le CPU, qui traitent les donn√©es instantan√©ment (1 cycle). Juste en dessous, le Cache (L1, L2, L3) sert de zone tampon pour anticiper les besoins du processeur. Plus bas, la RAM stocke les programmes en cours, et enfin le SSD assure le stockage permanent.

Pour que ces composants communiquent, l'ordinateur utilise des Bus :
Le Bus de Donn√©es transporte les valeurs (le "quoi").
Le Bus d'Adresses indique l'emplacement (le "o√π").
Le Bus de Contr√¥le envoie les ordres comme "Lecture" ou "√âcriture" (le "comment").
II. L'Organisation de la M√©moire en C (Stack vs Heap)
Lorsqu'un programme s'ex√©cute, il segmente sa m√©moire virtuelle en plusieurs zones :
La Stack (Pile) ü•û : Elle g√®re les variables locales de mani√®re automatique via des Stack Frames. C'est une structure LIFO (Dernier Entr√©, Premier Sorti). Si une fonction s'appelle √† l'infini, elle d√©passe sa zone r√©serv√©e, cr√©ant un Stack Overflow.
La Heap (Tas) üèóÔ∏è : C'est l'espace pour l'allocation dynamique avec malloc(). Ici, c'est au programmeur de lib√©rer la m√©moire avec free().
Le Segment de Donn√©es : Contient les variables globales et les constantes (comme les cha√Ænes de caract√®res en lecture seule, le .rodata).
III. Le M√©canisme du Segmentation Fault (Aspect Mat√©riel)
Le Segfault n'est pas qu'une erreur logicielle, c'est une intervention de la s√©curit√© mat√©rielle. Chaque programme manipule des adresses virtuelles (une illusion cr√©√©e par l'OS). Pour acc√©der √† la vraie RAM, il doit passer par la MMU (Memory Management Unit), un composant physique du processeur.

La MMU consulte une Table des Pages (fournie par l'OS) qui contient les droits d'acc√®s. Le crash survient dans trois cas principaux :
Adresse inexistante : Tu essaies d'acc√©der √† une adresse qui n'est pas mapp√©e dans la table (ex: d√©r√©f√©rencer un pointeur NULL).
Violation de droits : Tu essaies d'√©crire dans une zone marqu√©e "Lecture seule" (comme modifier une cha√Æne constante).
D√©passement de segment : Tu sors des limites de ta "bulle" de m√©moire virtuelle.
Lorsque la MMU d√©tecte l'infraction, elle l√®ve une exception mat√©rielle. Le CPU s'arr√™te et passe le relais au noyau du syst√®me d'exploitation, qui envoie le signal SIGSEGV pour tuer le processus.

IV. Diagnostics et Concepts Avanc√©s
Pour comprendre un crash, on utilise le Core Dump, une copie conforme de la RAM et des registres au moment fatidique, que l'on analyse avec un d√©bogueur comme gdb.

Nous avons aussi vu deux variantes critiques :
Le Bus Error (SIGBUS) üìè : Souvent d√ª √† un probl√®me d'alignement m√©moire. Le CPU refuse de lire une donn√©e si elle n'est pas plac√©e sur une adresse multiple de sa taille (ex: un int de 4 octets commen√ßant √† une adresse impaire).
Le Buffer Overflow üö© : C'est une faille o√π l'on √©crit plus de donn√©es que pr√©vu dans un tableau sur la Stack. Cela permet d'√©craser l'adresse de retour de la fonction pour d√©tourner le CPU vers du code malveillant. Pour contrer cela, le mat√©riel utilise le NX Bit (No-Execute), emp√™chant l'ex√©cution de code dans les zones de donn√©es.
V. La M√©moire Virtuelle et le Swap
Enfin, la m√©moire virtuelle permet d'utiliser le SSD comme extension de la RAM. Si la RAM est pleine, l'OS d√©place des pages de donn√©es vers le disque (Swap). Cela √©vite le crash imm√©diat mais ralentit √©norm√©ment l'ordinateur car le bus vers le SSD est bien plus lent que celui vers la RAM.