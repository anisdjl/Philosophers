Stack:

The stack is a lifo data structure which means the last data stored in it is the first one out of it
Stored in computer RAM just like the heap.
Variables created on the stack will go out of scope and are automatically deallocated.
Much faster to allocate in comparison to variables on the heap.
Implemented with an actual stack data structure.
Stores local data, return addresses, used for parameter passing.
Can have a stack overflow when too much of the stack is used (mostly from infinite or too deep recursion, very large allocations).
Data created on the stack can be used without pointers.
You would use the stack if you know exactly how much data you need to allocate before compile time and it is not too big.
Usually has a maximum size already determined when your program starts.

Heap:

Stored in computer RAM just like the stack.
In C++, variables on the heap must be destroyed manually and never fall out of scope. The data is freed with delete, delete[], or free.
Slower to allocate in comparison to variables on the stack.
Used on demand to allocate a block of data for use by the program.
Can have fragmentation when there are a lot of allocations and deallocations.
In C++ or C, data created on the heap will be pointed to by pointers and allocated with new or malloc respectively.
Can have allocation failures if too big of a buffer is requested to be allocated.
You would use the heap if you don't know exactly how much data you will need at run time or if you need to allocate a lot of data.
Responsible for memory leaks.

1. Les Bus : Les autoroutes de l'information ğŸšŒ
Un bus est un ensemble de liaisons physiques (des fils Ã©lectriques sur la carte mÃ¨re) qui permettent de transfÃ©rer des donnÃ©es entre les composants d'un ordinateur (CPU, mÃ©moire, pÃ©riphÃ©riques).

On distingue gÃ©nÃ©ralement trois types de bus :
Le Bus de DonnÃ©es ğŸ“¦ : Il transporte les informations rÃ©elles (le contenu d'une variable, une instruction de code).
Le Bus d'Adresses ğŸ“ : Il indique oÃ¹ envoyer la donnÃ©e (l'adresse mÃ©moire en RAM). Plus ce bus est large (ex: 64 bits), plus l'ordinateur peut gÃ©rer une grande quantitÃ© de mÃ©moire.
Le Bus de ContrÃ´le ğŸš¦ : Il transporte les ordres (ex: "Lire", "Ã‰crire", "Interrompre").

2. La HiÃ©rarchie de la MÃ©moire ğŸ”ï¸
Comme nous l'avons vu, la mÃ©moire est organisÃ©e en pyramide. Plus on monte vers le CPU, plus c'est rapide, mais plus c'est petit et cher.
Registres âš¡ : Directement dans le CPU. Vitesse instantanÃ©e.
MÃ©moire Cache (L1, L2, L3) ğŸï¸ : IntÃ©grÃ©e ou proche du CPU. Stocke ce qui est utilisÃ© frÃ©quemment.
MÃ©moire Vive (RAM) ğŸ§Š : Stockage temporaire pour les programmes en cours d'exÃ©cution.
Stockage de masse (SSD/HDD) ğŸ“š : Permanent, trÃ¨s lent par rapport au CPU.

Le trajet de la donnÃ©e ğŸ›¤ï¸
Le Stockage (SSD/HDD) ğŸ’¾ : Avant que vous ne lanciez le programme, le code compilÃ© (binaire) et les donnÃ©es dorment sur le disque dur.
La RAM (MÃ©moire vive) ğŸ§Š : Quand vous lancez l'exÃ©cutable, le systÃ¨me d'exploitation charge les instructions en RAM. Une zone appelÃ©e Stack (Pile) est rÃ©servÃ©e pour les variables locales comme a et b.
Le Cache ğŸï¸ : Le processeur anticipe et copie les valeurs de a et b depuis la RAM vers le Cache (L1/L2) pour y accÃ©der plus vite.
Les Registres âš¡ : Pour effectuer l'addition (a + b), le CPU transfÃ¨re les valeurs du Cache vers ses Registres internes. C'est seulement ici que l'unitÃ© de calcul peut manipuler les nombres.

un Dangling Pointer (un pointeur qui pointe vers du vide ou "n'importe quoi").

Au niveau du matÃ©riel, un Segfault est un signal d'arrÃªt d'urgence envoyÃ© par le processeur.

La MÃ©moire Virtuelle et la MMU ğŸ§ 
Ton programme ne parle jamais directement aux puces de RAM physiques. Il utilise des adresses virtuelles. Entre le processeur et la RAM, il y a un composant physique essentiel appelÃ© la MMU (Memory Management Unit).

Voici ce qui se passe lors d'une erreur :
La Table des Pages ğŸ“– : Le systÃ¨me d'exploitation crÃ©e une carte (une table) qui dit : "Le programme A a le droit d'accÃ©der aux adresses de 100 Ã  200".
La RequÃªte âœ‹ : Ton processeur essaie d'exÃ©cuter une instruction comme MOV (dÃ©placer une donnÃ©e) vers une adresse interdite (par exemple l'adresse 0, ou une adresse appartenant Ã  un autre programme).
Le Verdict de la MMU âŒ : La MMU vÃ©rifie la table. Si l'adresse n'est pas rÃ©pertoriÃ©e ou si les droits (lecture/Ã©criture) ne correspondent pas, elle bloque l'accÃ¨s instantanÃ©ment.
L'Exception MatÃ©rielle âš¡ : La MMU envoie une "exception" au processeur. Le processeur arrÃªte tout et passe la main au noyau (Kernel) du systÃ¨me d'exploitation, qui envoie alors le signal SIGSEGV Ã  ton programme pour le tuer proprement avant qu'il ne corrompe les donnÃ©es des autres.
Pourquoi c'est une protection vitale ? ğŸ›¡ï¸
Sans ce mÃ©canisme matÃ©riel, si ton programme faisait une erreur, il pourrait aller Ã©crire par accident dans la mÃ©moire du systÃ¨me d'exploitation ou d'un autre logiciel (comme ton navigateur web), ce qui ferait planter tout l'ordinateur.

Pour bien visualiser cela, on peut regarder deux causes matÃ©rielles frÃ©quentes :
L'accÃ¨s hors limites : Ton pointeur pointe vers une zone qui n'a jamais Ã©tÃ© "mappÃ©e" (allouÃ©e) par la MMU.
La violation de droits : Tu essaies d'Ã©crire dans une zone marquÃ©e comme "Lecture seule" (comme la zone oÃ¹ est stockÃ© le code mÃªme de ton programme).

1. Le Core Dump (La boÃ®te noire) ğŸ“‚
Oui, tu peux l'ouvrir ! Sous Linux, on utilise souvent un outil appelÃ© gdb (GNU Debugger).
Quand tu lances gdb mon_programme core, le dÃ©bogueur te place exactement Ã  l'endroit oÃ¹ Ã§a a cassÃ©.
Tu peux taper une commande comme backtrace pour voir la liste des fonctions qui Ã©taient en cours d'exÃ©cution.
C'est magique car cela t'Ã©vite de chercher des heures avec des printf.